<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lua Editor</title>
    <link rel="icon" type="image/png" sizes="32x32" href="/logos/lua-icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/logos/lua-icon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/logos/lua-icon-180x180.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1e1e1e;
            font-family: 'Fira Code', monospace;
        }

        #editor {
            position: absolute;
            top: 0;
            right: 120px;
            bottom: 0;
            left: 0;
            width: calc(100% - 120px);
            height: 100vh;
            font-feature-settings: "liga" 1, "calt" 1;
        }

        .ace_cursor {
            animation: blink 1.2s cubic-bezier(0.78, 0.14, 0.15, 0.86) infinite !important;
        }

        @keyframes blink {
            0%,
            100% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }
        }

        .ace_selection {
            animation: selectionFade 0.3s ease-out;
        }

        @keyframes selectionFade {
            from {
                background-color: #ffffff50;
            }

            to {
                background-color: #49483E;
            }
        }

        .ace_active-line {
            animation: activeLine 0.3s ease-out;
        }

        @keyframes activeLine {
            from {
                background-color: transparent;
            }

            to {
                background-color: #3c3c3c;
            }
        }

        .ace_bracket {
            animation: bracketMatch 0.5s ease infinite alternate;
        }

        @keyframes bracketMatch {
            from {
                border-color: #f8f8f2;
            }

            to {
                border-color: #66d9ef;
            }
        }

        .ace_autocomplete {
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .ace_text-input {
            transition: all 0.3s ease-out !important;
        }

        .ace_scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .ace_scrollbar::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }

        .ace_scrollbar::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .ace_scrollbar::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        .ace_gutter-cell {
            transition: background-color 0.2s, color 0.2s;
        }

        .ace_selection {
            background: #ffffff15 !important;
        }

        .ace_active-line {
            transition: background-color 0.2s ease-out;
            background: #2a2a2a !important;
        }

        .ace_editor {
            display: flex;
            flex-direction: row;
            opacity: 0;
            animation: fadeIn 0.3s ease-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        #minimap {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 120px;
            background: #1e1e1e;
            overflow: hidden;
            z-index: 10;
            opacity: 0.6;
            transition: opacity 0.2s;
            border-left: 1px solid #333;
            cursor: pointer;
            opacity: 0.4;
        }

        #minimap:hover {
            opacity: 1;
        }

        #minimap-content {
            transform-origin: top left;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            white-space: pre;
        }

        #minimap-slider {
            position: absolute;
            right: 0;
            width: 120px;
            background: rgba(255, 255, 255, 0.2);
            pointer-events: none;
            border-radius: 3px;
        }

        .ace_editor * {
            transition: none;
        }

        .ace_line {
            transition: none;
        }

        .ace_text-input {
            transition: none !important;
        }

        .ace_gutter-cell {
            transition: background-color 0.2s ease-out;
        }

        .ace_marker-layer .ace_selection {
            transition: background-color 0.2s ease-out;
        }

        .ace_marker-layer .ace_active-line {
            transition: background-color 0.2s ease-out;
        }

        .ace_cursor {
            transition: border-color 0.2s ease-out;
        }

        .ace_hidden-cursors .ace_cursor {
            transition: opacity 0.2s ease-out;
        }

        .ace_smooth_scroll {
            transition: transform 0.2s ease-out;
        }

        .ace_scrollbar {
            transition: opacity 0.2s ease-out;
        }

        #minimap, #minimap-content, #minimap-slider {
            transition: all 0.2s ease-out;
        }

        .ace_gutter-cell {
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .ace_fold {
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .ace_marker-layer .ace_bracket {
            transition: border-color 0.3s ease;
        }

        .ace_marker-layer .ace_active-line {
            transition: background-color 0.3s ease;
        }

        .ace_gutter-active-line {
            transition: background-color 0.3s ease;
        }

        .ace_cursor {
            transition: border-color 0.3s ease;
        }

        .ace_hidden-cursors .ace_cursor {
            transition: opacity 0.3s ease;
        }

        .ace_smooth_scroll {
            transition: transform 0.3s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .ace_scrollbar {
            transition: opacity 0.3s ease;
        }

        .ace_autocomplete {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .ace_tooltip {
            transition: opacity 0.3s ease;
        }

        .ace_fold-widget {
            transition: transform 0.3s ease;
        }

        #minimap, #minimap-content, #minimap-slider {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Add neon text effect */
        .ace_editor {
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.4);
        }

        /* Different colors for different syntax elements */
        .ace_keyword {
            color: #ff79c6 !important;
            text-shadow: 0 0 2px rgba(255, 121, 198, 0.4),
                         0 0 4px rgba(255, 121, 198, 0.2);
        }

        .ace_string {
            color: #f1fa8c !important;
            text-shadow: 0 0 2px rgba(241, 250, 140, 0.4),
                         0 0 4px rgba(241, 250, 140, 0.2);
        }

        .ace_numeric {
            color: #bd93f9 !important;
            text-shadow: 0 0 2px rgba(189, 147, 249, 0.4),
                         0 0 4px rgba(189, 147, 249, 0.2);
        }

        .ace_function {
            color: #50fa7b !important;
            text-shadow: 0 0 2px rgba(80, 250, 123, 0.4),
                         0 0 4px rgba(80, 250, 123, 0.2);
        }

        .ace_operator {
            color: #ff79c6 !important;
            text-shadow: 0 0 2px rgba(255, 121, 198, 0.4),
                         0 0 4px rgba(255, 121, 198, 0.2);
        }

        .ace_comment {
            color: #6272a4 !important;
            text-shadow: 0 0 2px rgba(98, 114, 164, 0.4),
                         0 0 4px rgba(98, 114, 164, 0.2);
        }

        .ace_constant {
            color: #bd93f9 !important;
            text-shadow: 0 0 2px rgba(189, 147, 249, 0.4),
                         0 0 4px rgba(189, 147, 249, 0.2);
        }

        .ace_support.ace_function {
            color: #8be9fd !important;
            text-shadow: 0 0 2px rgba(139, 233, 253, 0.4),
                         0 0 4px rgba(139, 233, 253, 0.2);
        }

        .ace_variable {
            color: #f8f8f2 !important;
            text-shadow: 0 0 2px rgba(248, 248, 242, 0.4),
                         0 0 4px rgba(248, 248, 242, 0.2);
        }

        /* Add a subtle pulse animation to the cursor */
        .ace_cursor {
            border-left: 2px solid #f8f8f2 !important;
            animation: neonCursor 1.2s ease-in-out infinite !important;
        }

        @keyframes neonCursor {
            0%, 100% {
                border-color: #f8f8f2;
                box-shadow: 0 0 4px rgba(248, 248, 242, 0.4);
            }
            50% {
                border-color: rgba(248, 248, 242, 0.5);
                box-shadow: 0 0 8px rgba(248, 248, 242, 0.6);
            }
        }

        /* Selection highlight with neon effect */
        .ace_selection {
            background: rgba(189, 147, 249, 0.3) !important;
            box-shadow: 0 0 10px rgba(189, 147, 249, 0.2);
        }

        /* Active line highlight with subtle neon glow */
        .ace_active-line {
            background: rgba(44, 45, 56, 0.8) !important;
            box-shadow: inset 0 0 6px rgba(189, 147, 249, 0.2);
        }
    </style>
</head>

<body>
    <div id="editor">print("Hello, World!")</div>
    <div id="minimap">
        <div id="minimap-content"></div>
        <div id="minimap-slider"></div>
    </div>
    <script>
        let editor = ace.edit("editor");
        editor.setTheme("ace/theme/tomorrow_night");
        editor.session.setMode("ace/mode/lua");
        editor.setFontSize(14);
        editor.setShowPrintMargin(false);

        ace.require("ace/ext/language_tools");

        editor.setOptions({
            enableLiveAutocompletion: {
                enabled: true,
                triggerAfterInsert: true,
                triggerOnBackspace: true,
                triggerOnDelete: false,
                characterThreshold: 1,
                delay: 50,
                ghostText: true
            },
            enableSnippets: true,
            enableBasicAutocompletion: true,
            enableMultiselect: true,
            showInvisibles: false,
            wrap: true,
            autoScrollEditorIntoView: false,
            tooltipFollowsMouse: true,
            enableAutoIndent: true,
            behavioursEnabled: true,
            wrapBehavioursEnabled: true,
            maxTokens: 100000,
            tabSize: 4,
            useSoftTabs: true,
            navigateWithinSoftTabs: true,
            scrollPastEnd: 0.5,
            animatedScroll: true,
            displayIndentGuides: true,
            showGutter: true,
            printMarginColumn: 120,
            highlightSelectedWord: true,
            fixedWidthGutter: true,
            showLineNumbers: true,
            showFoldWidgets: true,
            fadeFoldWidgets: true,
            maxLines: null,
            minLines: null,
            scrollSpeed: 2,
            dragEnabled: true,
            highlightActiveLine: true,
            hScrollBarAlwaysVisible: false,
            vScrollBarAlwaysVisible: false,
            height: '100%',
            autoClosingBrackets: true,
            autoClosingQuotes: true
        });

        editor.commands.on('afterExec', function(e) {
            if (e.command.name === 'insertstring' && /^[\w.:]$/.test(e.args)) {
                clearTimeout(this.completionTimer);
                this.completionTimer = setTimeout(() => {
                    editor.execCommand('startAutocomplete');
                }, 50);
            }
        });

        editor.commands.addCommand({
            name: 'showAutocompletion',
            bindKey: {win: 'Ctrl-Space', mac: 'Command-Space'},
            exec: function(editor) {
                editor.execCommand('startAutocomplete');
            }
        });

        const style = document.createElement('style');
        style.textContent = `
            .ace_autocomplete {
                width: 280px !important;
                background: #282a36 !important;
                border: 1px solid #44475a !important;
                box-shadow: 0 2px 10px rgba(0,0,0,0.5) !important;
                border-radius: 6px !important;
                padding: 0 !important;
            }

            .ace_autocomplete .ace_completion-highlight {
                color: #ff79c6 !important;
                text-shadow: 0 0 2px rgba(255,121,198,0.4) !important;
            }

            .ace_autocomplete .ace_line-hover {
                background: #44475a !important;
                border: none !important;
            }

            .ace_autocomplete .ace_line {
                padding: 4px 8px !important;
            }

            .ace_autocomplete .ace_completion-meta {
                color: #6272a4 !important;
                font-style: italic !important;
                padding-left: 8px !important;
            }
        `;
        document.head.appendChild(style);

        editor.setOptions({
            enableLiveAutocompletion: {
                enabled: true,
                triggerAfterInsert: true,
                triggerOnBackspace: true,
                triggerOnDelete: false,
                characterThreshold: 1,
                delay: 100
            }
        });

        let luaCompleter = {
            getCompletions: function (editor, session, pos, prefix, callback) {
                const line = session.getLine(pos.row);
                const beforeCursor = line.slice(0, pos.column);
                
                
                luaParser.parseCode(session.getValue());
                
                let completions = [];
                
                
                const methodMatch = beforeCursor.match(/(\w+)[.:]\w*$/);
                if (methodMatch) {
                    const objectName = methodMatch[1];
                    const varInfo = luaParser.variables.get(objectName);
                    
                    if (varInfo && varInfo.type === 'RobloxService') {
                        
                        completions = luaParser.getServiceMethods(objectName);
                    } else {
                        
                        completions = this.getMethodCompletions(objectName);
                    }
                } else {
                    
                    const contextualCompletions = luaParser.getContextualCompletions(prefix, pos.row, pos.column);
                    
                    
                    const standardCompletions = this.getStandardCompletions();
                    
                     
                    completions = [...contextualCompletions, ...standardCompletions];
                    
                    
                    if (prefix) {
                        completions = completions.filter(completion => 
                            completion.caption ? 
                                completion.caption.toLowerCase().startsWith(prefix.toLowerCase()) :
                                completion.value.toLowerCase().startsWith(prefix.toLowerCase())
                        );
                    }
                    
                    
                    completions.sort((a, b) => {
                        if (a.score !== b.score) {
                            return b.score - a.score;
                        }
                        return (a.caption || a.value).localeCompare(b.caption || b.value);
                    });
                }
                
                callback(null, completions);
            },
            
            getMethodCompletions: function(objectName) {
                
                const methodCompletions = {
                    string: [
                        { value: 'len()', score: 1000, meta: 'method', docText: 'Returns the length of the string' },
                        { value: 'sub(start, end)', score: 1000, meta: 'method', docText: 'Returns substring from start to end' },
                        
                    ],
                    table: [
                        { value: 'insert(value)', score: 1000, meta: 'method', docText: 'Inserts value at the end of the table' },
                        { value: 'remove([pos])', score: 1000, meta: 'method', docText: 'Removes and returns element at position pos' },
                        
                    ],
                    
                };
                
                const varInfo = luaParser.variables.get(objectName);
                return varInfo && methodCompletions[varInfo.type] || [];
            },
            
            getStandardCompletions: function() {
                return [
                    // Lua Keywords with snippets
                    { caption: 'function', value: 'function', snippet: 'function ${1:name}(${2:params})\n\t${3}\nend', score: 1000, meta: 'keyword', ghostText: ' name()' },
                    { caption: 'if', value: 'if', snippet: 'if ${1:condition} then\n\t${2}\nend', score: 1000, meta: 'keyword', ghostText: ' condition then' },
                    { caption: 'for', value: 'for', snippet: 'for ${1:i}=${2:1},${3:10} do\n\t${4}\nend', score: 1000, meta: 'keyword', ghostText: ' i=1,10 do' },
                    { caption: 'while', value: 'while', snippet: 'while ${1:condition} do\n\t${2}\nend', score: 1000, meta: 'keyword', ghostText: ' condition do' },
                    
                    // Functions with brackets
                    { caption: 'print()', value: 'print', snippet: 'print(${1})', score: 900, meta: 'function', ghostText: '()' },
                    { caption: 'type()', value: 'type', snippet: 'type(${1})', score: 900, meta: 'function', ghostText: '()' },
                    { caption: 'tostring()', value: 'tostring', snippet: 'tostring(${1})', score: 900, meta: 'function', ghostText: '()' },
                    { caption: 'tonumber()', value: 'tonumber', snippet: 'tonumber(${1})', score: 900, meta: 'function', ghostText: '()' },
                    
                    // Math functions
                    { caption: 'math.abs()', value: 'math.abs', snippet: 'math.abs(${1})', score: 800, meta: 'math', ghostText: '()' },
                    { caption: 'math.floor()', value: 'math.floor', snippet: 'math.floor(${1})', score: 800, meta: 'math', ghostText: '()' },
                    { caption: 'math.ceil()', value: 'math.ceil', snippet: 'math.ceil(${1})', score: 800, meta: 'math', ghostText: '()' },
                    
                    // Table functions
                    { caption: 'table.insert()', value: 'table.insert', snippet: 'table.insert(${1:table}, ${2:value})', score: 800, meta: 'table', ghostText: '()' },
                    { caption: 'table.remove()', value: 'table.remove', snippet: 'table.remove(${1:table}, ${2:pos})', score: 800, meta: 'table', ghostText: '()' },
                    
                    // String functions
                    { caption: 'string.format()', value: 'string.format', snippet: 'string.format(${1:format}, ${2})', score: 800, meta: 'string', ghostText: '()' },
                    { caption: 'string.sub()', value: 'string.sub', snippet: 'string.sub(${1:str}, ${2:start}, ${3:end})', score: 800, meta: 'string', ghostText: '()' }
                ];
            },
            
            getCompletions: function(editor, session, pos, prefix, callback) {
                let completions = this.getStandardCompletions();
                
                // Filter completions based on prefix
                if (prefix) {
                    completions = completions.filter(completion => 
                        completion.caption.toLowerCase().startsWith(prefix.toLowerCase())
                    );
                }
                
                // Show ghost text for the selected completion
                editor.on('changeSelection', function() {
                    const pos = editor.getCursorPosition();
                    const token = editor.session.getTokenAt(pos.row, pos.column);
                    
                    if (token) {
                        const completion = completions.find(c => c.value === token.value);
                        if (completion && completion.ghostText) {
                            editor.renderer.setGhostText(pos, completion.ghostText, 0.4);
                        } else {
                            editor.renderer.clearGhostText();
                        }
                    }
                });
                
                callback(null, completions);
            }
        };

        editor.completers = [luaCompleter];

        function getCode() {
            return editor.getValue();
        }

        function setCode(code) {
            editor.setValue(code, -1);
        }

        editor.session.on('changeScrollTop', function (scrollTop) {
            requestAnimationFrame(() => {
                editor.renderer.scrollBar.element.style.transform =
                    `translateY(${scrollTop}px)`;
            });
        });

        editor.container.style.transition = 'box-shadow 0.3s ease';
        editor.on('focus', () => {
            editor.container.style.boxShadow = 'inset 0 0 0 2px #666';
        });
        editor.on('blur', () => {
            editor.container.style.boxShadow = 'none';
        });

        editor.renderer.setScrollMargin(10, 10, 0, 0);
        editor.renderer.setAnimatedScroll(true);

        let minimapEditor = ace.edit("minimap-content");
        minimapEditor.setTheme("ace/theme/tomorrow_night");
        minimapEditor.session.setMode("ace/mode/lua");
        minimapEditor.setReadOnly(true);
        minimapEditor.renderer.setShowGutter(false);
        minimapEditor.renderer.setShowPrintMargin(false);
        minimapEditor.renderer.hideCursor();
        minimapEditor.setHighlightActiveLine(false);
        minimapEditor.setShowPrintMargin(false);
        minimapEditor.setOptions({
            fontSize: "4px",
            fontFamily: "'Fira Code', monospace",
            highlightActiveLine: false,
            highlightGutterLine: false,
            showLineNumbers: false,
            showFoldWidgets: false,
            displayIndentGuides: false,
            showPrintMargin: false,
            maxLines: Infinity,
            wrap: false
        });

        editor.session.on('change', function() {
            minimapEditor.setValue(editor.getValue(), -1);
            updateMinimapScale();
        });

        minimapEditor.setValue(editor.getValue(), -1);
        updateMinimapScale();

        document.getElementById('minimap').addEventListener('click', function (e) {
            const totalHeight = editor.session.getLength() * editor.renderer.lineHeight;
            const clickRatio = e.offsetY / this.offsetHeight;
            const scrollTop = totalHeight * clickRatio - (editor.container.clientHeight / 2);
            editor.session.setScrollTop(scrollTop);
        });

        window.addEventListener('resize', updateMinimapScale);

        editor.container.style.right = '120px';

        function updateMinimapScale() {
            const editorHeight = editor.container.clientHeight;
            const totalLines = editor.session.getLength();
            const lineHeight = editor.renderer.lineHeight;
            const totalHeight = totalLines * lineHeight;
            const scale = Math.min(editorHeight / totalHeight, 1.2);
            
            const minimapContent = document.getElementById('minimap-content');
            minimapContent.style.transform = `scale(${scale})`;
            minimapContent.style.width = (120 / scale) + 'px';

            const sliderHeight = Math.max((editorHeight / totalHeight) * editorHeight, 30);
            const sliderTop = (editor.session.getScrollTop() / (totalHeight - editorHeight)) * (editorHeight - sliderHeight);
            const slider = document.getElementById('minimap-slider');
            slider.style.height = sliderHeight + 'px';
            slider.style.top = sliderTop + 'px';
        }

        editor.commands.addCommand({
            name: 'find',
            bindKey: {win: 'Ctrl-F', mac: 'Command-F'},
            exec: function(editor) {
                ace.require("ace/ext/searchbox").Search(editor);
            }
        });

        editor.commands.addCommand({
            name: 'replace',
            bindKey: {win: 'Ctrl-H', mac: 'Command-Option-F'},
            exec: function(editor) {
                ace.require("ace/ext/searchbox").Search(editor, true);
            }
        });

        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function(e) {
            e.preventDefault();
            
            if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    editor.setValue(e.target.result, -1);
                };
                
                reader.readAsText(file);
            }
        });

        let luaParser = {
            variables: new Map(),
            functions: new Map(),
            currentScope: [],
            services: new Map(),
            
            parseCode: function(code) {
                this.variables.clear();
                this.functions.clear();
                this.currentScope = [];
                this.services.clear();
                
                const lines = code.split('\n');
                let scope = 'global';
                let blockDepth = 0;
                
                lines.forEach((line, lineNumber) => {
                    // Parse Roblox service declarations
                    const serviceMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*game:GetService\(["']([^"']+)["']\)/);
                    if (serviceMatch) {
                        const [_, varName, serviceName] = serviceMatch;
                        this.services.set(varName, {
                            name: varName,
                            service: serviceName,
                            scope: scope,
                            line: lineNumber
                        });
                        this.variables.set(varName, {
                            name: varName,
                            type: 'RobloxService',
                            serviceType: serviceName,
                            scope: scope,
                            line: lineNumber
                        });
                    }
                    
                    // Parse local variables with assignment
                    const localAssignMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)/);
                    if (localAssignMatch && !serviceMatch) {
                        const [_, varName, value] = localAssignMatch;
                        this.variables.set(varName, {
                            name: varName,
                            scope: scope,
                            line: lineNumber,
                            type: this.inferType(value),
                            value: value.trim()
                        });
                    }
                    
                    // Parse local variables without assignment
                    const localDeclareMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*$/);
                    if (localDeclareMatch) {
                        const [_, varName] = localDeclareMatch;
                        this.variables.set(varName, {
                            name: varName,
                            scope: scope,
                            line: lineNumber,
                            type: 'unknown',
                            value: null
                        });
                    }
                    
                    // Track scope changes
                    if (line.match(/(function|do|then|repeat)\b/)) {
                        blockDepth++;
                        this.currentScope.push(`block_${blockDepth}`);
                    }
                    if (line.match(/(end)\b/)) {
                        this.currentScope.pop();
                        blockDepth = Math.max(0, blockDepth - 1);
                    }
                });
            },
            
            inferType: function(value) {
                if (!value) return 'unknown';
                if (value.match(/^["']/)) return 'string';
                if (value.match(/^\d/)) return 'number';
                if (value.match(/^(true|false)$/)) return 'boolean';
                if (value.match(/^{/)) return 'table';
                if (value.match(/^function/)) return 'function';
                if (value.match(/game:GetService/)) return 'RobloxService';
                if (value.match(/Instance\.new/)) return 'Instance';
                if (value.match(/Vector3\.new/)) return 'Vector3';
                if (value.match(/CFrame\.new/)) return 'CFrame';
                return 'unknown';
            },
            
            getContextualCompletions: function(prefix, row, column) {
                const completions = [];
                
                // Add variables in current scope
                this.variables.forEach((variable, name) => {
                    completions.push({
                        caption: name,
                        value: name,
                        score: 1200, // Higher score for user-defined variables
                        meta: variable.type,
                        type: variable.type,
                        docText: `${variable.type}${variable.value ? ` = ${variable.value}` : ''}`
                    });
                });
                
                // Add functions in current scope
                this.functions.forEach((func, name) => {
                    completions.push({
                        caption: `${name}(${func.params.join(', ')})`,
                        value: name,
                        score: 1200,
                        meta: 'function',
                        docText: `function(${func.params.join(', ')})`
                    });
                });
                
                return completions;
            },
            
            getServiceMethods: function(serviceName) {
                const serviceInfo = this.services.get(serviceName);
                if (!serviceInfo) return [];
                
                // Add service-specific methods based on the service type
                const serviceMethods = {
                    ReplicatedStorage: [
                        { value: ':WaitForChild()', score: 1000, meta: 'method', docText: 'Waits for a child to exist' },
                        { value: ':GetChildren()', score: 1000, meta: 'method', docText: 'Gets all children' },
                        { value: ':FindFirstChild()', score: 1000, meta: 'method', docText: 'Finds first child matching name' }
                    ],
                    Players: [
                        { value: ':GetPlayers()', score: 1000, meta: 'method', docText: 'Gets all players' },
                        { value: '.LocalPlayer', score: 1000, meta: 'property', docText: 'Local player instance' },
                        { value: ':GetPlayerFromCharacter()', score: 1000, meta: 'method', docText: 'Gets player from character' }
                    ],
                    // Add more services and their methods as needed
                };
                
                return serviceMethods[serviceInfo.service] || [];
            }
        };

        // Add these event listeners for better completion behavior
        editor.on('change', function(e) {
            // Parse code on change for real-time updates
            const code = editor.getValue();
            luaParser.parseCode(code);
        });

        // Add custom tooltips for function signatures
        editor.on('mousemove', function(e) {
            const pos = editor.getCursorPosition();
            const token = editor.session.getTokenAt(pos.row, pos.column);
            
            if (token && token.type === 'identifier') {
                const funcInfo = luaParser.functions.get(token.value);
                if (funcInfo) {
                    // Show function signature tooltip
                    // You'll need to implement the actual tooltip UI
                }
            }
        });

        // Enhance the autocompletion popup styles
        const enhancedStyles = `
            .ace_autocomplete {
                width: 350px !important;
            }
            
            .ace_autocomplete .ace_completion-meta {
                opacity: 0.7;
                font-size: 0.9em;
            }
            
            .ace_tooltip {
                background: #282a36;
                color: #f8f8f2;
                border: 1px solid #44475a;
                border-radius: 4px;
                padding: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                max-width: 400px;
                font-family: 'Fira Code', monospace;
            }
        `;

        style.textContent += enhancedStyles;

        // Add these styles for smoother popup animations
        const popupStyles = `
            .ace_autocomplete {
                transition: opacity 0.1s ease-in-out;
                opacity: 0;
                animation: fadeIn 0.1s ease-in-out forwards;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-5px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .ace_autocomplete .ace_line {
                transition: background-color 0.1s ease-in-out;
            }
            
            .ace_autocomplete .ace_completion-highlight {
                transition: color 0.1s ease-in-out;
            }
        `;

        style.textContent += popupStyles;

        // Update the editor's container style
        editor.container.style.height = '100%';
        editor.container.style.position = 'absolute';

        // Custom bracket completion with ghost text
        editor.commands.on('afterExec', function(e) {
            const pos = editor.getCursorPosition();
            const line = editor.session.getLine(pos.row);
            const token = editor.session.getTokenAt(pos.row, pos.column);
            
            if (token && token.type === 'identifier') {
                const word = token.value;
                const completions = {
                    'print': '()',
                    'function': ' ()',
                    'table.insert': '()',
                    'table.remove': '()',
                    'string.format': '()',
                    // Add more function names and their bracket pairs
                };

                if (completions[word]) {
                    // Show ghost text
                    const ghostText = completions[word];
                    editor.renderer.setGhostText(pos, ghostText, 0.4);
                    
                    // Handle tab completion
                    editor.commands.addCommand({
                        name: 'acceptGhostText',
                        bindKey: {win: 'Tab', mac: 'Tab'},
                        exec: function(editor) {
                            if (editor.renderer.ghostText) {
                                editor.insert(ghostText);
                                editor.renderer.clearGhostText();
                                return true;
                            }
                            return false;
                        }
                    });
                }
            }
        });

        // Add ghost text renderer
        ace.define('ace/ghost_text', [], function(require, exports, module) {
            'use strict';
            
            const dom = require('ace/lib/dom');
            
            class GhostTextRenderer {
                constructor(editor) {
                    this.editor = editor;
                    this.ghostText = null;
                    this.ghostMarker = null;
                    this.opacity = 0.4;
                    
                    this.element = dom.createElement('div');
                    this.element.className = 'ace_ghost_text';
                    this.element.style.position = 'absolute';
                    this.element.style.pointerEvents = 'none';
                    this.editor.renderer.scroller.appendChild(this.element);
                }
                
                setGhostText(position, text, opacity) {
                    this.ghostText = text;
                    this.opacity = opacity || 0.4;
                    this.position = position;
                    this.update();
                }
                
                clearGhostText() {
                    this.ghostText = null;
                    this.element.textContent = '';
                }
                
                update() {
                    if (!this.ghostText) return;
                    
                    const pos = this.editor.renderer.textToScreenCoordinates(
                        this.position.row,
                        this.position.column
                    );
                    
                    this.element.style.left = pos.pageX + 'px';
                    this.element.style.top = pos.pageY + 'px';
                    this.element.textContent = this.ghostText;
                    this.element.style.opacity = this.opacity;
                    this.element.style.color = 'inherit';
                }
            }
            
            exports.GhostTextRenderer = GhostTextRenderer;
        });

        // Initialize ghost text renderer
        const GhostTextRenderer = ace.require('ace/ghost_text').GhostTextRenderer;
        editor.renderer.ghostTextRenderer = new GhostTextRenderer(editor);
        editor.renderer.setGhostText = function(pos, text, opacity) {
            this.ghostTextRenderer.setGhostText(pos, text, opacity);
        };
        editor.renderer.clearGhostText = function() {
            this.ghostTextRenderer.clearGhostText();
        };

        // Add ghost text styles
        const ghostTextStyles = `
            .ace_ghost_text {
                font-family: inherit;
                font-size: inherit;
                color: #6272a4 !important;
                pointer-events: none;
                z-index: 5;
                text-shadow: 0 0 2px rgba(98, 114, 164, 0.4);
            }
        `;
        style.textContent += ghostTextStyles;

        // Add this event listener to handle ghost text on autocomplete selection
        editor.on('autocompletionSelect', function(e, completion) {
            if (completion && completion.ghostText) {
                const pos = editor.getCursorPosition();
                editor.renderer.setGhostText(pos, completion.ghostText, 0.4);
            }
        });
    </script>
</body>

</html>