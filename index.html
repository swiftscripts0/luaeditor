<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lua Editor</title>
    <link rel="icon" type="image/png" sizes="32x32" href="/logos/lua-icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/logos/lua-icon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/logos/lua-icon-180x180.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        /* Update base styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #191a21;  /* Darker background */
            font-family: 'Fira Code', monospace;
        }

        #editor {
            position: absolute;
            top: 0;
            right: 120px;
            bottom: 0;
            left: 0;
            width: calc(100% - 120px);
            height: 100vh;
            font-feature-settings: "liga" 1, "calt" 1;
            opacity: 0;
            animation: fadeIn 0.4s ease-out forwards;
        }

        /* Smoother animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .ace_cursor {
            animation: smoothBlink 1s cubic-bezier(0.4, 0, 0.2, 1) infinite !important;
        }

        @keyframes smoothBlink {
            0%, 100% {
                opacity: 0;
                box-shadow: 0 0 8px rgba(248, 248, 242, 0.6);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 12px rgba(248, 248, 242, 0.8);
            }
        }

        .ace_selection {
            background: rgba(189, 147, 249, 0.3) !important;
            border-radius: 2px;
        }

        .ace_selected-word {
            background: rgba(189, 147, 249, 0.2) !important;
            border: 1px solid rgba(189, 147, 249, 0.4) !important;
            border-radius: 2px;
        }

        .ace_selection {
            animation: none;
        }

        .ace_marker-layer .ace_selection {
            background: rgba(189, 147, 249, 0.3) !important;
            border-radius: 2px;
            position: absolute;
            z-index: 5;
        }

        .ace_marker-layer .ace_selected-word {
            background: rgba(189, 147, 249, 0.2) !important;
            border: 1px solid rgba(189, 147, 249, 0.4) !important;
            border-radius: 2px;
            position: absolute;
            z-index: 4;
        }

        .ace_active-line {
            animation: smoothActiveLine 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(41, 42, 51, 0.8) !important;
            box-shadow: inset 0 0 8px rgba(189, 147, 249, 0.2);
        }

        @keyframes smoothActiveLine {
            from {
                background-color: transparent;
                box-shadow: none;
            }
            to {
                background-color: rgba(41, 42, 51, 0.8);
                box-shadow: inset 0 0 8px rgba(189, 147, 249, 0.2);
            }
        }

        /* Enhanced scrollbar */
        .ace_scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .ace_scrollbar::-webkit-scrollbar-track {
            background: #282a36;
            border-radius: 4px;
        }

        .ace_scrollbar::-webkit-scrollbar-thumb {
            background: #44475a;
            border-radius: 4px;
            transition: background 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ace_scrollbar::-webkit-scrollbar-thumb:hover {
            background: #6272a4;
        }

        /* Enhanced minimap */
        #minimap {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 120px;
            background: #20212c;
            overflow: hidden;
            z-index: 10;
            opacity: 0.4;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-left: 1px solid #2c2d3a;
        }

        #minimap:hover {
            opacity: 1;
        }

        /* Smooth transitions for all interactive elements */
        .ace_editor *, 
        .ace_line,
        .ace_text-input,
        .ace_gutter-cell,
        .ace_marker-layer .ace_selection,
        .ace_marker-layer .ace_active-line,
        .ace_cursor,
        .ace_hidden-cursors .ace_cursor,
        .ace_smooth_scroll,
        .ace_scrollbar,
        #minimap,
        #minimap-content,
        #minimap-slider {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Enhanced autocomplete popup */
        .ace_autocomplete {
            background: #282a36 !important;
            border: 1px solid #44475a !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3) !important;
            border-radius: 6px !important;
            animation: smoothPopup 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes smoothPopup {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.98);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Enhanced syntax highlighting with subtle glow effects */
        .ace_keyword,
        .ace_operator {
            color: #ff79c6 !important;
            text-shadow: 0 0 8px rgba(255, 121, 198, 0.3);
        }

        .ace_function {
            color: #50fa7b !important;
            text-shadow: 0 0 8px rgba(80, 250, 123, 0.3);
        }

        .ace_string {
            color: #f1fa8c !important;
            text-shadow: 0 0 8px rgba(241, 250, 140, 0.3);
        }

        .ace_constant {
            color: #bd93f9 !important;
            text-shadow: 0 0 8px rgba(189, 147, 249, 0.3);
        }

        .ace_comment {
            color: #6272a4 !important;
            font-style: italic;
        }

        /* Ghost text enhancement */
        .ace_ghost_text {
            color: #6272a4 !important;
            opacity: 0.6;
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ace_ghost_text:hover {
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <div id="editor">print("Hello, World!")</div>
    <div id="minimap">
        <div id="minimap-content"></div>
        <div id="minimap-slider"></div>
    </div>
    <script>
        let editor = ace.edit("editor");
        editor.setTheme("ace/theme/tomorrow_night");
        editor.session.setMode("ace/mode/lua");
        editor.setFontSize(14);
        editor.setShowPrintMargin(false);

        ace.require("ace/ext/language_tools");

        editor.setOptions({
            enableLiveAutocompletion: {
                enabled: true,
                triggerAfterInsert: true,
                triggerOnBackspace: true,
                triggerOnDelete: false,
                characterThreshold: 1,
                delay: 50,
                ghostText: true
            },
            enableSnippets: true,
            enableBasicAutocompletion: true,
            enableMultiselect: true,
            showInvisibles: false,
            wrap: true,
            autoScrollEditorIntoView: false,
            tooltipFollowsMouse: true,
            enableAutoIndent: true,
            behavioursEnabled: true,
            wrapBehavioursEnabled: true,
            maxTokens: 100000,
            tabSize: 4,
            useSoftTabs: true,
            navigateWithinSoftTabs: true,
            scrollPastEnd: 0.5,
            animatedScroll: true,
            displayIndentGuides: true,
            showGutter: true,
            printMarginColumn: 120,
            highlightSelectedWord: true,
            fixedWidthGutter: true,
            showLineNumbers: true,
            showFoldWidgets: true,
            fadeFoldWidgets: true,
            maxLines: null,
            minLines: null,
            scrollSpeed: 2,
            dragEnabled: true,
            highlightActiveLine: true,
            hScrollBarAlwaysVisible: false,
            vScrollBarAlwaysVisible: false,
            height: '100%',
            autoClosingBrackets: true,
            autoClosingQuotes: true
        });

        editor.commands.on('afterExec', function(e) {
            if (e.command.name === 'insertstring' && /^[\w.:]$/.test(e.args)) {
                clearTimeout(this.completionTimer);
                this.completionTimer = setTimeout(() => {
                    editor.execCommand('startAutocomplete');
                }, 50);
            }
        });

        editor.commands.addCommand({
            name: 'showAutocompletion',
            bindKey: {win: 'Ctrl-Space', mac: 'Command-Space'},
            exec: function(editor) {
                editor.execCommand('startAutocomplete');
            }
        });

        const style = document.createElement('style');
        style.textContent = `
            .ace_autocomplete {
                width: 280px !important;
                background: #282a36 !important;
                border: 1px solid #44475a !important;
                box-shadow: 0 2px 10px rgba(0,0,0,0.5) !important;
                border-radius: 6px !important;
                padding: 0 !important;
            }

            .ace_autocomplete .ace_completion-highlight {
                color: #ff79c6 !important;
                text-shadow: 0 0 2px rgba(255,121,198,0.4) !important;
            }

            .ace_autocomplete .ace_line-hover {
                background: #44475a !important;
                border: none !important;
            }

            .ace_autocomplete .ace_line {
                padding: 4px 8px !important;
            }

            .ace_autocomplete .ace_completion-meta {
                color: #6272a4 !important;
                font-style: italic !important;
                padding-left: 8px !important;
            }
        `;
        document.head.appendChild(style);

        editor.setOptions({
            enableLiveAutocompletion: {
                enabled: true,
                triggerAfterInsert: true,
                triggerOnBackspace: true,
                triggerOnDelete: false,
                characterThreshold: 1,
                delay: 100
            }
        });

        // Add this variable tracking system before the luaCompleter
        const variableTracker = {
            variables: new Map(),
            
            parseCode: function(code) {
                this.variables.clear();
                const lines = code.split('\n');
                
                lines.forEach((line, lineNumber) => {
                    // Match local variable declarations
                    const localMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=?\s*(.*)/);
                    if (localMatch) {
                        const [_, varName, value] = localMatch;
                        this.variables.set(varName, {
                            name: varName,
                            value: value.trim(),
                            type: this.inferType(value.trim()),
                            line: lineNumber
                        });
                    }
                    
                    // Match function declarations
                    const functionMatch = line.match(/(?:local\s+)?function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*?)\)/);
                    if (functionMatch) {
                        const [_, funcName, params] = functionMatch;
                        this.variables.set(funcName, {
                            name: funcName,
                            type: 'function',
                            params: params.split(',').map(p => p.trim()),
                            line: lineNumber
                        });
                    }
                });
            },
            
            inferType: function(value) {
                if (!value) return 'unknown';
                if (value.match(/^["']/)) return 'string';
                if (value.match(/^\d/)) return 'number';
                if (value.match(/^(true|false)$/)) return 'boolean';
                if (value.match(/^{/)) return 'table';
                if (value.match(/^function/)) return 'function';
                if (value.match(/Instance\.new/)) return 'Instance';
                return 'unknown';
            }
        };

        // Update the luaCompleter's getCompletions function
        let luaCompleter = {
            getCompletions: function(editor, session, pos, prefix, callback) {
                // Don't show completions if we're not actively typing
                if (editor.completerIgnore) {
                    return callback(null, []);
                }

                const line = session.getLine(pos.row);
                const beforeCursor = line.slice(0, pos.column);
                
                // Parse current code to update variable tracking
                variableTracker.parseCode(editor.getValue());
                
                // Start with defined variables
                let completions = Array.from(variableTracker.variables.entries()).map(([name, info]) => ({
                    caption: info.type === 'function' ? `${name}(${info.params?.join(', ') || ''})` : name,
                    value: name,
                    score: 1200,
                    meta: info.type,
                    docText: `${info.type}${info.value ? ` = ${info.value}` : ''}`
                }));

                // Check for Roblox-specific contexts
                const isAfterGame = beforeCursor.match(/game:$/);
                const isTypingAfterColon = beforeCursor.match(/game:\w*$/);
                const isInGetService = beforeCursor.match(/game:GetService\(["']$/);
                const isTypingService = beforeCursor.match(/game:GetService\(["'][^"']*$/);

                // Add context-specific completions
                if (isAfterGame || isTypingAfterColon) {
                    completions.push(
                        { caption: 'GetService()', value: 'GetService("', score: 1100, meta: 'game', docText: 'Gets a Roblox service' },
                        { caption: 'FindFirstChild()', value: 'FindFirstChild("', score: 1100, meta: 'game', docText: 'Finds first child by name' },
                        { caption: 'WaitForChild()', value: 'WaitForChild("', score: 1100, meta: 'game', docText: 'Waits for child to exist' },
                        { caption: 'Destroy()', value: 'Destroy()', score: 1100, meta: 'game', docText: 'Destroys the object' },
                        { caption: 'Clone()', value: 'Clone()', score: 1100, meta: 'game', docText: 'Creates a copy of the object' }
                    );
                } else if (isInGetService || isTypingService) {
                    completions.push(
                        { caption: 'Players', value: 'Players")', score: 1100, meta: 'service', docText: 'Players service' },
                        { caption: 'Workspace', value: 'Workspace")', score: 1100, meta: 'service', docText: 'Workspace service' },
                        { caption: 'ReplicatedStorage', value: 'ReplicatedStorage")', score: 1100, meta: 'service', docText: 'ReplicatedStorage service' },
                        { caption: 'RunService', value: 'RunService")', score: 1100, meta: 'service', docText: 'RunService service' },
                        { caption: 'UserInputService', value: 'UserInputService")', score: 1100, meta: 'service', docText: 'UserInputService service' },
                        { caption: 'TweenService', value: 'TweenService")', score: 1100, meta: 'service', docText: 'TweenService service' },
                        { caption: 'HttpService', value: 'HttpService")', score: 1100, meta: 'service', docText: 'HttpService service' },
                        { caption: 'MarketplaceService', value: 'MarketplaceService")', score: 1100, meta: 'service', docText: 'MarketplaceService service' },
                        { caption: 'Lighting', value: 'Lighting")', score: 1100, meta: 'service', docText: 'Lighting service' },
                        { caption: 'SoundService', value: 'SoundService")', score: 1100, meta: 'service', docText: 'SoundService service' },
                        { caption: 'StarterGui', value: 'StarterGui")', score: 1100, meta: 'service', docText: 'StarterGui service' },
                        { caption: 'CoreGui', value: 'CoreGui")', score: 1100, meta: 'service', docText: 'CoreGui service' },
                        { caption: 'Debris', value: 'Debris")', score: 1100, meta: 'service', docText: 'Debris service' }
                    );
                } else {
                    // Add standard Lua functions
                    completions.push(
                        // Standard Lua Functions
                        { caption: 'print()', value: 'print(', score: 1000, meta: 'function', docText: 'Prints values to console' },
                        { caption: 'type()', value: 'type(', score: 1000, meta: 'function', docText: 'Returns the type of a value' },
                        { caption: 'pairs()', value: 'pairs(', score: 1000, meta: 'function', docText: 'Iterates over table key-value pairs' },
                        { caption: 'ipairs()', value: 'ipairs(', score: 1000, meta: 'function', docText: 'Iterates over table indices' },
                        { caption: 'tonumber()', value: 'tonumber(', score: 1000, meta: 'function', docText: 'Converts value to number' },
                        { caption: 'tostring()', value: 'tostring(', score: 1000, meta: 'function', docText: 'Converts value to string' },
                        
                        // Lua String Methods
                        { caption: 'string.len()', value: 'string.len(', score: 900, meta: 'string', docText: 'Returns string length' },
                        { caption: 'string.sub()', value: 'string.sub(', score: 900, meta: 'string', docText: 'Returns substring' },
                        { caption: 'string.upper()', value: 'string.upper(', score: 900, meta: 'string', docText: 'Converts to uppercase' },
                        { caption: 'string.lower()', value: 'string.lower(', score: 900, meta: 'string', docText: 'Converts to lowercase' },
                        
                        // Lua Table Methods
                        { caption: 'table.insert()', value: 'table.insert(', score: 900, meta: 'table', docText: 'Inserts element into table' },
                        { caption: 'table.remove()', value: 'table.remove(', score: 900, meta: 'table', docText: 'Removes element from table' },
                        { caption: 'table.concat()', value: 'table.concat(', score: 900, meta: 'table', docText: 'Concatenates table elements' },
                        
                        // Lua Math Methods
                        { caption: 'math.abs()', value: 'math.abs(', score: 900, meta: 'math', docText: 'Absolute value' },
                        { caption: 'math.ceil()', value: 'math.ceil(', score: 900, meta: 'math', docText: 'Rounds up' },
                        { caption: 'math.floor()', value: 'math.floor(', score: 900, meta: 'math', docText: 'Rounds down' },
                        
                        // Executor Functions
                        { caption: 'gethui()', value: 'gethui()', score: 1100, meta: 'executor', docText: 'Gets the hidden UI container' },
                        { caption: 'getgenv()', value: 'getgenv()', score: 1100, meta: 'executor', docText: 'Gets the global environment' },
                        { caption: 'getrenv()', value: 'getrenv()', score: 1100, meta: 'executor', docText: 'Gets the Roblox environment' },
                        { caption: 'hookfunction()', value: 'hookfunction(', score: 1100, meta: 'executor', docText: 'Hooks a function' },
                        { caption: 'hookmetamethod()', value: 'hookmetamethod(', score: 1100, meta: 'executor', docText: 'Hooks a metamethod' },
                        
                        // Roblox Globals
                        { caption: 'game', value: 'game', score: 1100, meta: 'global', docText: 'Roblox game instance' },
                        { caption: 'workspace', value: 'workspace', score: 1100, meta: 'global', docText: 'Roblox workspace' },
                        { caption: 'script', value: 'script', score: 1100, meta: 'global', docText: 'Current script instance' },
                        
                        // Roblox Constructors
                        { caption: 'Instance.new()', value: 'Instance.new("', score: 1000, meta: 'constructor', docText: 'Creates a new instance' },
                        { caption: 'Vector3.new()', value: 'Vector3.new(', score: 1000, meta: 'constructor', docText: 'Creates a new Vector3' },
                        { caption: 'CFrame.new()', value: 'CFrame.new(', score: 1000, meta: 'constructor', docText: 'Creates a new CFrame' },
                        { caption: 'Color3.fromRGB()', value: 'Color3.fromRGB(', score: 1000, meta: 'constructor', docText: 'Creates a new Color3' },
                        { caption: 'UDim2.new()', value: 'UDim2.new(', score: 1000, meta: 'constructor', docText: 'Creates a new UDim2' }
                    );
                }

                // Filter completions based on what's being typed
                if (prefix) {
                    const searchPrefix = prefix.toLowerCase();
                    completions = completions.filter(completion => {
                        const caption = completion.caption.toLowerCase();
                        return caption.includes(searchPrefix);
                    });
                    
                    // Sort completions by relevance
                    completions.sort((a, b) => {
                        const aStart = a.caption.toLowerCase().startsWith(searchPrefix);
                        const bStart = b.caption.toLowerCase().startsWith(searchPrefix);
                        if (aStart && !bStart) return -1;
                        if (!aStart && bStart) return 1;
                        return b.score - a.score;
                    });
                }

                callback(null, completions);
            }
        };

        editor.completers = [luaCompleter];

        function getCode() {
            return editor.getValue();
        }

        function setCode(code) {
            editor.setValue(code, -1);
        }

        editor.session.on('changeScrollTop', function (scrollTop) {
            requestAnimationFrame(() => {
                editor.renderer.scrollBar.element.style.transform =
                    `translateY(${scrollTop}px)`;
            });
        });

        editor.container.style.transition = 'box-shadow 0.3s ease';
        editor.on('focus', () => {
            editor.container.style.boxShadow = 'inset 0 0 0 2px #666';
        });
        editor.on('blur', () => {
            editor.container.style.boxShadow = 'none';
        });

        editor.renderer.setScrollMargin(10, 10, 0, 0);
        editor.renderer.setAnimatedScroll(true);

        let minimapEditor = ace.edit("minimap-content");
        minimapEditor.setTheme("ace/theme/tomorrow_night");
        minimapEditor.session.setMode("ace/mode/lua");
        minimapEditor.setReadOnly(true);
        minimapEditor.renderer.setShowGutter(false);
        minimapEditor.renderer.setShowPrintMargin(false);
        minimapEditor.renderer.hideCursor();
        minimapEditor.setHighlightActiveLine(false);
        minimapEditor.setShowPrintMargin(false);
        minimapEditor.setOptions({
            fontSize: "4px",
            fontFamily: "'Fira Code', monospace",
            highlightActiveLine: false,
            highlightGutterLine: false,
            showLineNumbers: false,
            showFoldWidgets: false,
            displayIndentGuides: false,
            showPrintMargin: false,
            maxLines: Infinity,
            wrap: false
        });

        editor.session.on('change', function() {
            minimapEditor.setValue(editor.getValue(), -1);
            updateMinimapScale();
        });

        minimapEditor.setValue(editor.getValue(), -1);
        updateMinimapScale();

        document.getElementById('minimap').addEventListener('click', function (e) {
            const totalHeight = editor.session.getLength() * editor.renderer.lineHeight;
            const clickRatio = e.offsetY / this.offsetHeight;
            const scrollTop = totalHeight * clickRatio - (editor.container.clientHeight / 2);
            editor.session.setScrollTop(scrollTop);
        });

        window.addEventListener('resize', updateMinimapScale);

        editor.container.style.right = '120px';

        function updateMinimapScale() {
            const editorHeight = editor.container.clientHeight;
            const totalLines = editor.session.getLength();
            const lineHeight = editor.renderer.lineHeight;
            const totalHeight = totalLines * lineHeight;
            const scale = Math.min(editorHeight / totalHeight, 1.2);
            
            const minimapContent = document.getElementById('minimap-content');
            minimapContent.style.transform = `scale(${scale})`;
            minimapContent.style.width = (120 / scale) + 'px';

            const sliderHeight = Math.max((editorHeight / totalHeight) * editorHeight, 30);
            const sliderTop = (editor.session.getScrollTop() / (totalHeight - editorHeight)) * (editorHeight - sliderHeight);
            const slider = document.getElementById('minimap-slider');
            slider.style.height = sliderHeight + 'px';
            slider.style.top = sliderTop + 'px';
        }

        editor.commands.addCommand({
            name: 'find',
            bindKey: {win: 'Ctrl-F', mac: 'Command-F'},
            exec: function(editor) {
                ace.require("ace/ext/searchbox").Search(editor);
            }
        });

        editor.commands.addCommand({
            name: 'replace',
            bindKey: {win: 'Ctrl-H', mac: 'Command-Option-F'},
            exec: function(editor) {
                ace.require("ace/ext/searchbox").Search(editor, true);
            }
        });

        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function(e) {
            e.preventDefault();
            
            if (e.dataTransfer.files.length) {
                const file = e.dataTransfer.files[0];
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    editor.setValue(e.target.result, -1);
                };
                
                reader.readAsText(file);
            }
        });

        let luaParser = {
            variables: new Map(),
            functions: new Map(),
            currentScope: [],
            services: new Map(),
            
            parseCode: function(code) {
                this.variables.clear();
                this.functions.clear();
                this.currentScope = [];
                this.services.clear();
                
                const lines = code.split('\n');
                let scope = 'global';
                let blockDepth = 0;
                
                lines.forEach((line, lineNumber) => {
                    // Parse Roblox service declarations
                    const serviceMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*game:GetService\(["']([^"']+)["']\)/);
                    if (serviceMatch) {
                        const [_, varName, serviceName] = serviceMatch;
                        this.services.set(varName, {
                            name: varName,
                            service: serviceName,
                            scope: scope,
                            line: lineNumber
                        });
                        this.variables.set(varName, {
                            name: varName,
                            type: 'RobloxService',
                            serviceType: serviceName,
                            scope: scope,
                            line: lineNumber
                        });
                    }
                    
                    // Parse local variables with assignment
                    const localAssignMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.+)/);
                    if (localAssignMatch && !serviceMatch) {
                        const [_, varName, value] = localAssignMatch;
                        this.variables.set(varName, {
                            name: varName,
                            scope: scope,
                            line: lineNumber,
                            type: this.inferType(value),
                            value: value.trim()
                        });
                    }
                    
                    // Parse local variables without assignment
                    const localDeclareMatch = line.match(/local\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*$/);
                    if (localDeclareMatch) {
                        const [_, varName] = localDeclareMatch;
                        this.variables.set(varName, {
                            name: varName,
                            scope: scope,
                            line: lineNumber,
                            type: 'unknown',
                            value: null
                        });
                    }
                    
                    // Track scope changes
                    if (line.match(/(function|do|then|repeat)\b/)) {
                        blockDepth++;
                        this.currentScope.push(`block_${blockDepth}`);
                    }
                    if (line.match(/(end)\b/)) {
                        this.currentScope.pop();
                        blockDepth = Math.max(0, blockDepth - 1);
                    }
                });
            },
            
            inferType: function(value) {
                if (!value) return 'unknown';
                if (value.match(/^["']/)) return 'string';
                if (value.match(/^\d/)) return 'number';
                if (value.match(/^(true|false)$/)) return 'boolean';
                if (value.match(/^{/)) return 'table';
                if (value.match(/^function/)) return 'function';
                if (value.match(/game:GetService/)) return 'RobloxService';
                if (value.match(/Instance\.new/)) return 'Instance';
                if (value.match(/Vector3\.new/)) return 'Vector3';
                if (value.match(/CFrame\.new/)) return 'CFrame';
                return 'unknown';
            },
            
            getContextualCompletions: function(prefix, row, column) {
                const completions = [];
                
                // Add variables in current scope
                this.variables.forEach((variable, name) => {
                    completions.push({
                        caption: name,
                        value: name,
                        score: 1200, // Higher score for user-defined variables
                        meta: variable.type,
                        type: variable.type,
                        docText: `${variable.type}${variable.value ? ` = ${variable.value}` : ''}`
                    });
                });
                
                // Add functions in current scope
                this.functions.forEach((func, name) => {
                    completions.push({
                        caption: `${name}(${func.params.join(', ')})`,
                        value: name,
                        score: 1200,
                        meta: 'function',
                        docText: `function(${func.params.join(', ')})`
                    });
                });
                
                return completions;
            },
            
            getServiceMethods: function(serviceName) {
                const serviceInfo = this.services.get(serviceName);
                if (!serviceInfo) return [];
                
                // Add service-specific methods based on the service type
                const serviceMethods = {
                    ReplicatedStorage: [
                        { value: ':WaitForChild()', score: 1000, meta: 'method', docText: 'Waits for a child to exist' },
                        { value: ':GetChildren()', score: 1000, meta: 'method', docText: 'Gets all children' },
                        { value: ':FindFirstChild()', score: 1000, meta: 'method', docText: 'Finds first child matching name' }
                    ],
                    Players: [
                        { value: ':GetPlayers()', score: 1000, meta: 'method', docText: 'Gets all players' },
                        { value: '.LocalPlayer', score: 1000, meta: 'property', docText: 'Local player instance' },
                        { value: ':GetPlayerFromCharacter()', score: 1000, meta: 'method', docText: 'Gets player from character' }
                    ],
                    // Add more services and their methods as needed
                };
                
                return serviceMethods[serviceInfo.service] || [];
            }
        };

        // Update the afterExec handler to be smarter about when to show completions
        editor.commands.on('afterExec', function(e) {
            if (e.command.name === 'insertstring' || e.command.name === 'backspace') {
                const pos = editor.getCursorPosition();
                const line = editor.session.getLine(pos.row);
                const beforeCursor = line.slice(0, pos.column);
                
                // Don't trigger inside strings or comments
                const tokenType = editor.session.getTokenAt(pos.row, pos.column)?.type;
                if (tokenType && (tokenType.includes('string') || tokenType.includes('comment'))) {
                    return;
                }

                // Clear previous timer
                clearTimeout(this.completionTimer);
                
                // Set a flag to ignore completions
                editor.completerIgnore = false;
                
                // Check if we should show completions
                const shouldShowCompletions = 
                    beforeCursor.match(/\w+$/) || // Word being typed
                    beforeCursor.match(/[\w_]+:$/) || // After colon
                    beforeCursor.match(/[\w_]+\.$/) || // After dot
                    beforeCursor.match(/^local\s+\w*$/); // After local keyword

                if (shouldShowCompletions) {
                    this.completionTimer = setTimeout(() => {
                        editor.execCommand('startAutocomplete');
                    }, 0);
                }
            }
        });

        // Add handler for when completion is finished
        editor.on('changeSelection', function() {
            const pos = editor.getCursorPosition();
            const line = editor.session.getLine(pos.row);
            const beforeCursor = line.slice(0, pos.column);
            
            // If we're at a word boundary or after certain characters, mark to ignore completions
            if (!beforeCursor.match(/[\w_.:]\w*$/)) {
                editor.completerIgnore = true;
            }
        });

        // Update code change handler to parse variables
        editor.on('change', function(e) {
            variableTracker.parseCode(editor.getValue());
        });

        // Add custom tooltips for function signatures
        editor.on('mousemove', function(e) {
            const pos = editor.getCursorPosition();
            const token = editor.session.getTokenAt(pos.row, pos.column);
            
            if (token && token.type === 'identifier') {
                const funcInfo = luaParser.functions.get(token.value);
                if (funcInfo) {
                    // Show function signature tooltip
                    // You'll need to implement the actual tooltip UI
                }
            }
        });

        // Enhance the autocompletion popup styles
        const enhancedStyles = `
            .ace_autocomplete {
                width: 350px !important;
            }
            
            .ace_autocomplete .ace_completion-meta {
                opacity: 0.7;
                font-size: 0.9em;
            }
            
            .ace_tooltip {
                background: #282a36;
                color: #f8f8f2;
                border: 1px solid #44475a;
                border-radius: 4px;
                padding: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                max-width: 400px;
                font-family: 'Fira Code', monospace;
            }
        `;

        style.textContent += enhancedStyles;

        // Add these styles for smoother popup animations
        const popupStyles = `
            .ace_autocomplete {
                transition: opacity 0.1s ease-in-out;
                opacity: 0;
                animation: fadeIn 0.1s ease-in-out forwards;
            }
            
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-5px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            .ace_autocomplete .ace_line {
                transition: background-color 0.1s ease-in-out;
            }
            
            .ace_autocomplete .ace_completion-highlight {
                transition: color 0.1s ease-in-out;
            }
        `;

        style.textContent += popupStyles;

        // Update the editor's container style
        editor.container.style.height = '100%';
        editor.container.style.position = 'absolute';

        // Custom bracket completion with ghost text
        editor.commands.on('afterExec', function(e) {
            const pos = editor.getCursorPosition();
            const line = editor.session.getLine(pos.row);
            const token = editor.session.getTokenAt(pos.row, pos.column);
            
            if (token && token.type === 'identifier') {
                const word = token.value;
                const completions = {
                    'print': '()',
                    'function': ' ()',
                    'table.insert': '()',
                    'table.remove': '()',
                    'string.format': '()',
                    // Add more function names and their bracket pairs
                };

                if (completions[word]) {
                    // Show ghost text
                    const ghostText = completions[word];
                    editor.renderer.setGhostText(pos, ghostText, 0.4);
                    
                    // Handle tab completion
                    editor.commands.addCommand({
                        name: 'acceptGhostText',
                        bindKey: {win: 'Tab', mac: 'Tab'},
                        exec: function(editor) {
                            if (editor.renderer.ghostText) {
                                editor.insert(ghostText);
                                editor.renderer.clearGhostText();
                                return true;
                            }
                            return false;
                        }
                    });
                }
            }
        });

        // Add ghost text renderer
        ace.define('ace/ghost_text', [], function(require, exports, module) {
            'use strict';
            
            const dom = require('ace/lib/dom');
            
            class GhostTextRenderer {
                constructor(editor) {
                    this.editor = editor;
                    this.ghostText = null;
                    this.ghostMarker = null;
                    this.opacity = 0.4;
                    
                    this.element = dom.createElement('div');
                    this.element.className = 'ace_ghost_text';
                    this.element.style.position = 'absolute';
                    this.element.style.pointerEvents = 'none';
                    this.editor.renderer.scroller.appendChild(this.element);
                }
                
                setGhostText(position, text, opacity) {
                    this.ghostText = text;
                    this.opacity = opacity || 0.4;
                    this.position = position;
                    this.update();
                }
                
                clearGhostText() {
                    this.ghostText = null;
                    this.element.textContent = '';
                }
                
                update() {
                    if (!this.ghostText) return;
                    
                    const pos = this.editor.renderer.textToScreenCoordinates(
                        this.position.row,
                        this.position.column
                    );
                    
                    this.element.style.left = pos.pageX + 'px';
                    this.element.style.top = pos.pageY + 'px';
                    this.element.textContent = this.ghostText;
                    this.element.style.opacity = this.opacity;
                    this.element.style.color = 'inherit';
                }
            }
            
            exports.GhostTextRenderer = GhostTextRenderer;
        });

        // Initialize ghost text renderer
        const GhostTextRenderer = ace.require('ace/ghost_text').GhostTextRenderer;
        editor.renderer.ghostTextRenderer = new GhostTextRenderer(editor);
        editor.renderer.setGhostText = function(pos, text, opacity) {
            this.ghostTextRenderer.setGhostText(pos, text, opacity);
        };
        editor.renderer.clearGhostText = function() {
            this.ghostTextRenderer.clearGhostText();
        };

        // Add ghost text styles
        const ghostTextStyles = `
            .ace_ghost_text {
                font-family: inherit;
                font-size: inherit;
                color: #6272a4 !important;
                pointer-events: none;
                z-index: 5;
                text-shadow: 0 0 2px rgba(98, 114, 164, 0.4);
            }
        `;
        style.textContent += ghostTextStyles;

        // Add this event listener to handle ghost text on autocomplete selection
        editor.on('autocompletionSelect', function(e, completion) {
            if (completion && completion.ghostText) {
                const pos = editor.getCursorPosition();
                editor.renderer.setGhostText(pos, completion.ghostText, 0.4);
            }
        });

        // Add custom executor theme
        editor.setTheme({
            isDark: true,
            cssClass: "ace-executor",
            cssText: `
                .ace-executor {
                    background-color: #191a21;
                    color: #f8f8f2;
                }
                .ace-executor .ace_gutter {
                    background: #20212c;
                    color: #6272a4;
                    border-right: 1px solid #2c2d3a;
                }
                /* ... rest of your theme settings ... */
            `
        });

        // Add executor-specific keyboard shortcuts
        editor.commands.addCommand({
            name: 'execute',
            bindKey: {win: 'Ctrl-Enter', mac: 'Command-Enter'},
            exec: function(editor) {
                // Add your execution logic here
                console.log('Executing script:', editor.getValue());
            }
        });

        editor.commands.addCommand({
            name: 'clearEditor',
            bindKey: {win: 'Ctrl-L', mac: 'Command-L'},
            exec: function(editor) {
                editor.setValue('', -1);
            }
        });

        // Add this to handle better insertion of completions
        editor.commands.on('afterExec', function(e) {
            if (e.command.name === 'insertstring' || e.command.name === 'backspace') {
                const pos = editor.getCursorPosition();
                const line = editor.session.getLine(pos.row);
                const beforeCursor = line.slice(0, pos.column);
                
                // Don't trigger inside strings or comments
                const tokenType = editor.session.getTokenAt(pos.row, pos.column)?.type;
                if (tokenType && (tokenType.includes('string') || tokenType.includes('comment'))) {
                    return;
                }

                // Clear previous timer
                clearTimeout(this.completionTimer);
                
                // Set a flag to ignore completions
                editor.completerIgnore = false;
                
                // Check if we should show completions
                const shouldShowCompletions = 
                    beforeCursor.match(/\w+$/) || // Word being typed
                    beforeCursor.match(/[\w_]+:$/) || // After colon
                    beforeCursor.match(/[\w_]+\.$/) || // After dot
                    beforeCursor.match(/^local\s+\w*$/); // After local keyword

                if (shouldShowCompletions) {
                    this.completionTimer = setTimeout(() => {
                        editor.execCommand('startAutocomplete');
                    }, 0);
                }
            }
        });
    </script>
</body>

</html>